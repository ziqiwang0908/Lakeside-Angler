<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lakeside Angler - Realistic Fishing Prototype</title>
    <style>
        :root {
            --water-top: #2c5d63;
            --water-bottom: #0e1c1e;
            --sky-gradient: linear-gradient(to bottom, #74ebd5, #acb6e5);
            --ui-font: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: var(--sky-gradient);
            font-family: var(--ui-font);
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
            text-align: center;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .status-text {
            font-size: 2rem;
            font-weight: bold;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .instruction {
            font-size: 1rem;
            opacity: 0.8;
        }

        #inventory {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="mainCanvas"></canvas>
    
    <div id="ui-layer">
        <p class="status-text" id="status">Ready to Cast</p>
        <p class="instruction" id="hint">Click anywhere on the water</p>
    </div>

    <div id="inventory">
        Fish Caught: <span id="catch-count">0</span>
    </div>
</div>

<script>
/**
 * LAKESIDE ANGLER - Prototype
 * Logic Separation: 
 * - Renderer: WebGL-inspired 2D Canvas context
 * - State Machine: Fishing cycle (Idle, Cast, Waiting, Nibble, Bite, Reeling)
 * - Entities: Bobber, Fish, Rod
 */

const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status');
const hintEl = document.getElementById('hint');
const catchEl = document.getElementById('catch-count');

// --- Configuration & Constants ---
const WATER_LEVEL = 0.4; // Percentage of screen height where water starts
const FISH_COUNT = 6;
const STATES = {
    IDLE: 'IDLE',
    CASTING: 'CASTING',
    WAITING: 'WAITING',
    NIBBLE: 'NIBBLE',
    BITE: 'BITE',
    REELING: 'REELING',
    CAUGHT: 'CAUGHT'
};

// --- Game State ---
let currentState = STATES.IDLE;
let width, height;
let mouseX = 0, mouseY = 0;
let caughtCount = 0;
let time = 0;

const bobber = {
    x: 0,
    y: 0,
    targetX: 0,
    targetY: 0,
    velY: 0,
    isSet: false,
    bobAmount: 0,
    timer: 0
};

const rod = {
    tipX: 0,
    tipY: 0,
    baseX: 0,
    baseY: 0
};

class Fish {
    constructor() {
        this.reset();
    }
    reset() {
        this.x = Math.random() * width;
        this.y = (height * WATER_LEVEL) + Math.random() * (height * (1 - WATER_LEVEL));
        this.speed = 0.5 + Math.random() * 1.5;
        this.dir = Math.random() > 0.5 ? 1 : -1;
        this.size = 20 + Math.random() * 30;
        this.sinOffset = Math.random() * Math.PI * 2;
    }
    update() {
        this.x += this.speed * this.dir;
        if (this.x > width + 100) this.x = -100;
        if (this.x < -100) this.x = width + 100;
    }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y + Math.sin(time * 0.002 + this.sinOffset) * 10);
        ctx.scale(this.dir, 1);
        ctx.fillStyle = 'rgba(0, 40, 40, 0.3)';
        
        // Simple fish silhouette
        ctx.beginPath();
        ctx.ellipse(0, 0, this.size, this.size / 2.5, 0, 0, Math.PI * 2);
        ctx.fill();
        // Tail
        ctx.beginPath();
        ctx.moveTo(-this.size, 0);
        ctx.lineTo(-this.size - 10, -10);
        ctx.lineTo(-this.size - 10, 10);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
}

const fishPool = Array.from({ length: FISH_COUNT }, () => new Fish());

// --- Core Logic ---

function init() {
    resize();
    window.addEventListener('resize', resize);
    canvas.addEventListener('mousedown', handleInteraction);
    requestAnimationFrame(loop);
}

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    rod.baseX = width + 50;
    rod.baseY = height + 50;
    rod.tipX = width * 0.85;
    rod.tipY = height * 0.45;
}

function setState(nextState) {
    currentState = nextState;
    switch(nextState) {
        case STATES.IDLE:
            statusEl.innerText = "Ready to Cast";
            hintEl.innerText = "Click on the water";
            bobber.isSet = false;
            break;
        case STATES.WAITING:
            statusEl.innerText = "Waiting...";
            hintEl.innerText = "Watch the bobber";
            bobber.timer = 3000 + Math.random() * 5000;
            break;
        case STATES.NIBBLE:
            statusEl.innerText = "Wait for it...";
            bobber.timer = 1000 + Math.random() * 2000;
            break;
        case STATES.BITE:
            statusEl.innerText = "STRIKE!";
            hintEl.innerText = "CLICK NOW!";
            bobber.timer = 1200; // Time window to catch
            break;
        case STATES.CAUGHT:
            caughtCount++;
            catchEl.innerText = caughtCount;
            statusEl.innerText = "CAUGHT!";
            hintEl.innerText = "Click to reset";
            break;
    }
}

function handleInteraction(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (currentState === STATES.IDLE) {
        if (y > height * WATER_LEVEL) {
            bobber.targetX = x;
            bobber.targetY = y;
            bobber.x = rod.tipX;
            bobber.y = rod.tipY;
            bobber.isSet = true;
            setState(STATES.CASTING);
        }
    } else if (currentState === STATES.BITE) {
        setState(STATES.CAUGHT);
    } else if (currentState === STATES.CAUGHT || currentState === STATES.WAITING || currentState === STATES.NIBBLE) {
        setState(STATES.IDLE);
    }
}

function update(dt) {
    time += dt;

    // Bobber Physics Simulation (Spring/Buoyancy approximation)
    if (bobber.isSet) {
        if (currentState === STATES.CASTING) {
            bobber.x += (bobber.targetX - bobber.x) * 0.1;
            bobber.y += (bobber.targetY - bobber.y) * 0.1;
            if (Math.abs(bobber.x - bobber.targetX) < 1) setState(STATES.WAITING);
        } else {
            // Idle bobbing
            let baseBob = Math.sin(time * 0.005) * 3;
            
            if (currentState === STATES.NIBBLE) {
                baseBob = Math.sin(time * 0.05) * 6; // Fast jitter
            } else if (currentState === STATES.BITE) {
                baseBob = 15; // Pulled under
            }

            bobber.y = bobber.targetY + baseBob;
            
            // State Timers
            bobber.timer -= dt;
            if (bobber.timer <= 0) {
                if (currentState === STATES.WAITING) setState(STATES.NIBBLE);
                else if (currentState === STATES.NIBBLE) setState(STATES.BITE);
                else if (currentState === STATES.BITE) setState(STATES.IDLE); // Escaped
            }
        }
    }

    fishPool.forEach(f => f.update());
}

// --- Rendering ---

function draw() {
    // 1. Draw Sky/Background
    const skyGrad = ctx.createLinearGradient(0, 0, 0, height * WATER_LEVEL);
    skyGrad.addColorStop(0, '#74ebd5');
    skyGrad.addColorStop(1, '#acb6e5');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, width, height * WATER_LEVEL);

    // 2. Draw Underwater Depth
    const waterGrad = ctx.createLinearGradient(0, height * WATER_LEVEL, 0, height);
    waterGrad.addColorStop(0, '#2c5d63');
    waterGrad.addColorStop(1, '#0e1c1e');
    ctx.fillStyle = waterGrad;
    ctx.fillRect(0, height * WATER_LEVEL, width, height * (1 - WATER_LEVEL));

    // 3. Draw Fish (Silhouettes)
    fishPool.forEach(f => f.draw(ctx));

    // 4. Draw Water Surface (Animated Waves)
    drawWaves();

    // 5. Draw Fishing Line
    if (bobber.isSet) {
        ctx.beginPath();
        ctx.moveTo(rod.tipX, rod.tipY);
        
        // Quadratic curve for line slack/tension
        const ctrlX = (rod.tipX + bobber.x) / 2;
        const ctrlY = (rod.tipY + bobber.y) / 2 + (currentState === STATES.BITE ? -20 : 40);
        
        ctx.quadraticCurveTo(ctrlX, ctrlY, bobber.x, bobber.y);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 2]);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // 6. Draw Bobber
    if (bobber.isSet) {
        // Shadow/Ripple
        ctx.beginPath();
        ctx.ellipse(bobber.x, bobber.targetY + 5, 15 + Math.sin(time*0.01)*5, 5, 0, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fill();

        // The Float
        ctx.fillStyle = '#ff4b2b'; // Top red
        ctx.beginPath();
        ctx.arc(bobber.x, bobber.y - 8, 8, Math.PI, 0);
        ctx.fill();
        ctx.fillStyle = 'white'; // Bottom white
        ctx.beginPath();
        ctx.arc(bobber.x, bobber.y - 8, 8, 0, Math.PI);
        ctx.fill();
        // Antenna
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(bobber.x, bobber.y - 16);
        ctx.lineTo(bobber.x, bobber.y - 25);
        ctx.stroke();
    }

    // 7. Draw Fishing Rod
    ctx.save();
    ctx.strokeStyle = '#3d2b1f';
    ctx.lineWidth = 8;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(rod.baseX, rod.baseY);
    ctx.lineTo(rod.tipX, rod.tipY);
    ctx.stroke();
    
    // Rod Handle
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 12;
    ctx.beginPath();
    ctx.moveTo(rod.baseX, rod.baseY);
    ctx.lineTo(rod.baseX - (rod.baseX - rod.tipX)*0.2, rod.baseY - (rod.baseY - rod.tipY)*0.2);
    ctx.stroke();
    ctx.restore();
}

function drawWaves() {
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
    ctx.lineWidth = 2;

    const step = 40;
    const yStart = height * WATER_LEVEL;
    
    for (let i = 0; i < 5; i++) {
        ctx.beginPath();
        const yBase = yStart + (i * 25);
        ctx.moveTo(0, yBase);
        
        for (let x = 0; x <= width; x += step) {
            const waveH = Math.sin((x * 0.01) + (time * 0.002) + i) * 5;
            ctx.lineTo(x, yBase + waveH);
        }
        ctx.stroke();
    }
    ctx.restore();
}

let lastTime = 0;
function loop(now) {
    const dt = now - lastTime;
    lastTime = now;
    
    update(dt);
    draw();
    requestAnimationFrame(loop);
}

// Start
init();
</script>
</body>
</html>